// Copyright 2013 Bobby Powers. All rights reserved.
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

define([], function() {
    var runtime = {};
    // quoted from 'lib/runtime_src.js' file
    runtime.preamble = "var Simulation = function() {}\nSimulation.prototype.init = function(name, initials, timespec, tables, mapping) {\n    this.name = name;\n    this.initials = initials;\n    this.timespec = timespec;\n    this.tables = tables;\n    this.v = mapping;\n    this.nVars = Object.keys(this.v).length;\n\n    this.reset();\n};\nSimulation.prototype.reset = function() {\n    const timespec = this.timespec;\n\n    this.stepNum = 0;\n    this.saveNum = 0;\n\n    this.history = [];\n\n    this.curr = new Float64Array(this.nVars);\n    this.next = new Float64Array(this.nVars);\n\n    this.curr[this.v.time] = timespec.start;\n\n    var nSteps = ((timespec.stop - timespec.start)/timespec.savestep + 1)|0\n    this.saveEvery = Math.max(1, (timespec.savestep/timespec.dt+.5)|0)\n\n    this.timeSeries = new Float64Array(nSteps);\n\n    this.calcInitial(this.timespec.dt);\n};\nSimulation.prototype.runTo = function(time) {\n    const timeOff = this.v.time;\n    const dt = this.timespec.dt;\n\n    while (this.curr[timeOff] <= time) {\n        this.calcFlows(dt);\n        this.calcStocks(dt);\n\n        if (this.stepNum % this.saveEvery == 0) {\n            this.timeSeries[this.saveNum] = this.curr[timeOff];\n            this.history.push(this.curr);\n\n            this.saveNum++;\n        }\n        this.stepNum++;\n\n        this.next[timeOff] = this.curr[timeOff] + dt;\n        this.curr = this.next;\n        this.next = new Float64Array(this.nVars);\n    }\n};\nSimulation.prototype.runToEnd = function() {\n    return this.runTo(this.timespec.stop + .5*this.timespec.dt)\n};\nSimulation.prototype.setValue = function(name, value) {\n    this.curr[this.v[name]] = value;\n}\nSimulation.prototype.value = function(name) {\n    return this.history[Math.max(this.saveNum-1, 0)][this.v[name]];\n};\nSimulation.prototype.series = function(name) {\n    var time = this.timeSeries.subarray(0, this.saveNum);\n    var values = new Float64Array(time.length);\n    var off = this.v[name];\n    var i;\n    for (i=0; i < time.length; i++)\n        values[i] = this.history[i][off];\n    return {\n        'name': name,\n        'time': time,\n        'values': values,\n    };\n};\n\nvar handleMessage = function(e) {\n    var id = e.data[0];\n    var cmd = e.data[1];\n    var args = e.data.slice(2);\n    var result;\n\n    if (cmds.hasOwnProperty(cmd))\n        result = cmds[cmd].apply(this, args);\n    else\n        result = [null, 'unknown command \"' + cmd + '\"'];\n\n    if (!Array.isArray(result))\n        result = [null, 'no result for [' + e.data.join(', ') + ']'];\n\n    // TODO(bp) look into transferrable objects\n    var msg = [id, result];\n    postMessage(msg);\n};\n\nvar initCmds = function(main) {\n    return {\n        'reset': function() {\n            main.reset();\n            return ['ok', null];\n        },\n        'set_val': function(name, val) {\n            main.setValue(name, val);\n            return ['ok', null];\n        },\n        'get_val': function() {\n            var result = {};\n            var i;\n            for (i=0; i < arguments.length; i++)\n                result[arguments[i]] = main.value(arguments[i]);\n            return [result, null];\n        },\n        'get_series': function(name) {\n            var result = {};\n            var i;\n            for (i=0; i<arguments.length; i++)\n                result[arguments[i]] = main.series(arguments[i]);\n            return [result, null];\n        },\n        'run_to': function(time) {\n            main.runTo(time);\n            return [main.curr.time, null];\n        },\n        'run_to_end': function() {\n            main.runToEnd();\n            return [main.curr.time, null];\n        },\n    };\n};\n\nconst lookup = function(table, index) {\n    const size = table.x.length;\n    if (size === 0)\n        return NaN;\n\n    const x = table.x;\n    const y = table.y;\n\n    if (index <= x[0])\n        return y[0];\n    else if (index >= x[size - 1])\n        return y[size - 1];\n\n    // binary search seems to be the most appropriate choice here.\n    var low = 0;\n    var high = size;\n    var mid;\n    while (low < high) {\n        mid = Math.floor(low + (high - low)/2);\n        if (x[mid] < index) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n\n    var i = low;\n    if (x[i] === index) {\n        return y[i];\n    } else {\n        // slope = deltaY/deltaX\n        const slope = (y[i] - y[i-1]) / (x[i] - x[i-1]);\n        // y = m*x + b\n        return (index - x[i-1])*slope + y[i-1];\n    }\n};\n\nconst max = function(a, b) {\n    return a > b ? a : b;\n};\n\nconst min = function(a, b) {\n    return a < b ? a : b;\n};";

    return runtime;
});

